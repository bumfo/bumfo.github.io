<!doctype html>
<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Editor</title>

<article id="editor" contenteditable>
    <h3>heading3</h3>
    <p>div1</p>
    <p>div2</p>
    <p>div3</p>
    <p id="p4">p4</p>
</article>

<button id="btn">Do it</button>
<div contenteditable id="div5" tabindex="-1"></div>

<script>
"use strict"

let editor = document.querySelector('#editor')
let btn = document.querySelector('#btn')
let p4 = document.querySelector('#p4')
let div5 = document.querySelector('#div5')

let savedRange = null

function preventDefault(e) {
    e.preventDefault()
}

function execCommand(command, value = null) {
    if (!document.execCommand(command, false, value)) {
        throw new Error(command)
    }
}

function saveSelection() {
    let selection = window.getSelection()
    let range = selection.getRangeAt(0)
    console.log(range)
    savedRange = range
}

function restoreSelection() {
    if (savedRange !== null) {
        let selection = window.getSelection()
        selection.removeAllRanges()
        selection.addRange(savedRange)
    }
}

function addLine(history = false) {
    if (editor.contains(p4)) return false
    editor.insertBefore(p4, null)

    if (!history) {
        let tmpRange = document.createRange()
        tmpRange.selectNodeContents(div5)
        let selection = window.getSelection()
        selection.removeAllRanges()
        selection.addRange(tmpRange)
        execCommand('delete')
    }
}

function deleteLine(history = false) {
    if (!editor.contains(p4)) return false
    p4.remove()

    if (!history) {
        let tmpRange = document.createRange()
        tmpRange.selectNodeContents(div5)
        let selection = window.getSelection()
        selection.removeAllRanges()
        selection.addRange(tmpRange)
        execCommand('insertText', 'delete p4')
    }
}

btn.addEventListener('mousedown', preventDefault)
btn.addEventListener('focus', preventDefault)
btn.addEventListener('click', function () {
    saveSelection()
    deleteLine()
    restoreSelection()
})

div5.addEventListener('beforeinput', function (e) {
    saveSelection()
})
div5.addEventListener('input', function (e) {
    console.log(e.inputType, e)
    switch (e.inputType) {
        case 'historyUndo':
            addLine(true)
            restoreSelection()
            break
        case 'historyRedo':
            deleteLine(true)
            restoreSelection()
            break
    }
})

div5.addEventListener('focus', function (e) {
    e.preventDefault()
    e.target.blur()
    requestAnimationFrame(restoreSelection)
})

document.querySelectorAll('[contenteditable]').forEach(el => {
    // el.addEventListener('mousedown', preventDefault)
})

editor.addEventListener('mousedown', function (e) {
    let el = e.target
    if (el !== editor) {
        while (el.parentNode !== editor) {
            el = el.parentNode
        }
        let contenteditable = el.hasAttribute('contenteditable') || editor.hasAttribute('contenteditable')
        if (!contenteditable) {
            console.log('set contenteditable')
            el.setAttribute('contenteditable', '')
            console.log(el)
            // el.addEventListener('blur', function onblur(e) {
            // 	console.log('blur', el)
            // 	el.removeAttribute('contenteditable')
            // 	el.removeEventListener('blur', onblur)
            // })
        }
    }
})
editor.addEventListener('keydown', function (e) {
    function handleEnter() {
        if (!e.shiftKey) {
            e.preventDefault()
        }
    }

    function handleTab() {
        e.preventDefault()
    }

    function handleBackspace(isForward = false) {
        let selection = window.getSelection()
        if (selection.rangeCount === 0) {
            e.preventDefault()
            return
        }
        let range = selection.getRangeAt(0)
        if (!range.collapsed) {
            e.preventDefault()
            return
        }

        let block = range.startContainer
        if (block !== editor) {
            while (block.parentNode !== editor) {
                block = block.parentNode
            }
        }

        console.log('absolute', block, BlockText.getVisibleOffsetFromBlockStart(range))

        if (!isForward) {
            if (range.startContainer === editor) {
                block = editor.childNodes[range.startOffset]
                if (block !== null && block.firstChild !== null) {
                    range.setStartBefore(block.firstChild)
                    console.log(range)
                }

                if (block === null) return
            }

            if (BlockText.isAtBlockStart(range)) {
                let tag = block.previousElementSibling.tagName
                if (tag !== block.tagName) {
                    e.preventDefault()
                    let el = document.createElement(tag)
                    while (block.firstChild) {
                        el.appendChild(block.firstChild)
                    }

                    block.parentNode.replaceChild(el, block)
                } else {
                    e.preventDefault()
                }

                return
            }
        } else {
            if (BlockText.isAtBlockEnd(range)) {
                e.preventDefault()
                return
            }
        }

        let container = range.startContainer
        let offset = range.startOffset

        console.log('range', container, offset)

        if (container.nodeType === Node.TEXT_NODE) {
            let tmpRange = document.createRange()
            tmpRange.setStartBefore(block)
            tmpRange.setEnd(container, offset)
            console.log(JSON.stringify(tmpRange.toString()))

            // let div = document.createElement('div')
            // div.insertBefore(tmpRange.cloneContents(), null)
            // console.log(div.innerText)
            //
            // document.body.appendChild(div)
        }
    }

    switch (e.key) {
        case 'Enter':
            handleEnter()
            break
        case 'Tab':
            handleTab()
            break
        case 'Backspace':
            handleBackspace(false)
            break
        case 'Delete':
            handleBackspace(true)
            break
    }
})
editor.addEventListener('paste', function (e) {
    e.preventDefault()
})

editor.addEventListener('beforeinput', function (e) {
    let selection = window.getSelection()
    if (!selection.isCollapsed) {
        // e.preventDefault()
        execCommand('delete')
    }
})

/**
 * Block text utilities (layout-free).
 *
 * Public API:
 *   isAtBlockStart(input, opts?)
 *   isAtBlockEnd(input, opts?)
 *   getVisibleOffsetFromBlockStart(input, opts?)  // offset to the chosen boundary (start by default)
 *
 * Notes:
 * - `input` can be a Selection or a Range.
 * - By default:
 *    - CSS is respected to detect blocks and pre-like whitespace (no layout forced).
 *    - display:none / [hidden] content is ignored.
 *    - NBSP counts as visible (1 char).
 *    - Zero-width codepoints are ignored.
 *    - <br> counts as 1 visible char (represented as "\n" conceptually).
 */
const BlockText = (() => {
    const BANNED = /^(SCRIPT|STYLE|NOSCRIPT|TEMPLATE)$/;

    function isSelection(x) {
        return x && typeof x.getRangeAt === 'function' && x.rangeCount > 0;
    }

    function toRange(input) {
        if (input instanceof Range) return input.cloneRange();
        if (isSelection(input)) return input.getRangeAt(0).cloneRange();
        return null;
    }

    function nearestBlockAncestor(node, {respectCSS}) {
        if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;
        for (let cur = node; cur && cur.nodeType === 1; cur = cur.parentNode) {
            const el = /** @type {Element} */(cur);
            if (!respectCSS) {
                // Quick fallback: common block-ish tags
                if (/^(P|DIV|LI|BLOCKQUOTE|SECTION|ARTICLE|ASIDE|MAIN|HEADER|FOOTER|UL|OL|TABLE|TR|TD|TH|FIGURE|FIGCAPTION|FIELDSET|LEGEND|NAV|DL|DT|DD|H[1-6])$/.test(el.tagName)) {
                    return el;
                }
            } else {
                const d = getComputedStyle(el).display;
                if (
                    d === 'block' || d === 'flow-root' || d === 'list-item' ||
                    d === 'table' || d === 'table-row-group' || d === 'table-header-group' ||
                    d === 'table-footer-group' || d === 'table-row' || d === 'table-cell' ||
                    d === 'grid' || d === 'flex'
                ) return el;
            }
        }
        return null;
    }

    function isPreLike(el, respectCSS) {
        if (!el) return false;
        if (el.closest('pre,textarea')) return true;
        if (!respectCSS) return false;
        for (let cur = el; cur; cur = cur.parentElement) {
            const ws = getComputedStyle(cur).whiteSpace;
            if (ws === 'pre' || ws === 'pre-wrap') return true;
            if (ws === 'nowrap') return false; // still collapses ASCII spaces
        }
        return false;
    }

    function isAtomicInline(el, respectCSS) {
        const tag = el.tagName;
        if (/^(IMG|INPUT|BUTTON|SELECT|TEXTAREA|VIDEO|AUDIO|IFRAME|CANVAS|SVG|MATH|PROGRESS|METER|EMBED|OBJECT)$/.test(tag)) {
            return true;
        }
        if (!respectCSS) return false;
        const d = getComputedStyle(el).display;
        return d === 'inline-block' || d === 'inline-flex' || d === 'inline-grid';
    }

    function hasHiddenAncestor(el, stopAt, respectCSS) {
        for (let cur = el; cur && cur !== stopAt.parentElement; cur = cur.parentElement) {
            if (cur.hidden) return true;
            if (respectCSS) {
                const cs = getComputedStyle(cur);
                if (cs.display === 'none') return true;
            }
        }
        return false;
    }

    function isBanned(el) {
        return BANNED.test(el.tagName);
    }

    function isInBannedContainer(el) {
        for (let cur = el; cur; cur = cur.parentElement) if (isBanned(cur)) return true;
        return false;
    }

    function intersects(range, node) {
        if (typeof range.intersectsNode === 'function') {
            try {
                return range.intersectsNode(node);
            } catch { /* old engines */
            }
        }
        const r = (node.ownerDocument || document).createRange();
        try {
            r.selectNode(node);
        } catch {
            if (node.nodeType === Node.TEXT_NODE) {
                r.setStart(node, 0);
                r.setEnd(node, node.nodeValue ? node.nodeValue.length : 0);
            } else {
                return false;
            }
        }
        return !(r.compareBoundaryPoints(Range.END_TO_START, range) <= 0 ||
            r.compareBoundaryPoints(Range.START_TO_END, range) >= 0);
    }

    function collapsedBoundaryRange(input, edge) {
        const r = toRange(input);
        if (!r) return null;
        const out = r.cloneRange();
        if (edge === 'end') out.collapse(false); else out.collapse(true);
        return out;
    }

    function sliceRange(block, edgeRange, side /* 'before' | 'after' */) {
        const doc = block.ownerDocument || document;
        const s = doc.createRange();
        if (side === 'before') {
            s.setStart(block, 0);
            s.setEnd(edgeRange.startContainer, edgeRange.startOffset);
        } else {
            s.setStart(edgeRange.endContainer, edgeRange.endOffset);
            s.setEnd(block, block.childNodes.length);
        }
        return s;
    }

    function makeWalker(block, slice, {respectCSS, skipHidden}) {
        const doc = block.ownerDocument || document;
        return doc.createTreeWalker(
            block,
            NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
            {
                acceptNode(node) {
                    if (!intersects(slice, node)) return NodeFilter.FILTER_REJECT;

                    if (node.nodeType === Node.TEXT_NODE) {
                        const parent = node.parentElement;
                        if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
                        if (skipHidden && hasHiddenAncestor(parent, block, respectCSS)) return NodeFilter.FILTER_REJECT;
                        if (isInBannedContainer(parent)) return NodeFilter.FILTER_REJECT;
                        return NodeFilter.FILTER_ACCEPT;
                    }

                    const el = /** @type {Element} */(node);
                    if (isBanned(el)) return NodeFilter.FILTER_REJECT;
                    if (skipHidden && hasHiddenAncestor(el, block, respectCSS)) return NodeFilter.FILTER_REJECT;
                    // Count <br> or atomic inlines as visible tokens
                    if (el.tagName === 'BR' || isAtomicInline(el, respectCSS)) return NodeFilter.FILTER_ACCEPT;
                    return NodeFilter.FILTER_SKIP;
                },
            },
        );
    }

    function textPartForNodeInSlice(node, slice, edge, side) {
        // Return the substring of a text node that's inside the slice
        let t = node.nodeValue || '';
        if (node === slice.startContainer && node.nodeType === Node.TEXT_NODE) {
            if (side === 'after') t = t.slice(slice.startOffset);
        }
        if (node === slice.endContainer && node.nodeType === Node.TEXT_NODE) {
            if (side === 'before') t = t.slice(0, slice.endOffset);
        }
        return t;
    }

    function countVisibleInSlice(block, edgeRange, side, opts) {
        const {
            respectCSS = false,
            skipHidden = false,
            ignoreZeroWidth = false,
            treatNbspAsContent = true,
            brAs = '\n',
        } = opts || {};

        const slice = sliceRange(block, edgeRange, side);
        const walker = makeWalker(block, slice, {respectCSS, skipHidden});

        // State for normal collapsing across nodes
        let visibleCount = 0;
        let lastWasSpace = (side === 'before'); // at true → drop an initial join-space at the very start of the block

        let n;
        while ((n = walker.nextNode())) {
            if (n.nodeType === Node.ELEMENT_NODE) {
                // <br> or atomic inline
                visibleCount += 1;                 // treat as 1 visible char
                lastWasSpace = /\s$/.test(brAs);   // newline acts like a space at boundary
                continue;
            }

            // TEXT node
            let t = textPartForNodeInSlice(n, slice, edgeRange, side);

            if (!t) continue;

            // Normalize
            if (t.indexOf('\u0000') !== -1) t = t.replace(/\u0000/g, '');
            if (ignoreZeroWidth) t = t.replace(/[\u200B\u200C\u200D\uFEFF]/g, '');

            const NBSP = '\u00A0';
            const parentEl = /** @type {Text} */(n).parentElement;
            const preLike = isPreLike(parentEl, respectCSS);

            if (!treatNbspAsContent) t = t.replaceAll(NBSP, ' ');

            if (side === 'after') {
                // For end-check behavior later, we only need to know "is anything visible?"
                // But for offset counting we still need the full length; this function provides that.
            }

            if (preLike) {
                t = t.replace(/\r\n?/g, '\n'); // normalize CRLF
                // In pre-like, everything counts verbatim
                visibleCount += t.length;
                lastWasSpace = /\s$/.test(t);
            } else {
                // Collapse ASCII whitespace to single space
                t = t.replace(/[\t\n\r\f ]+/g, ' ');
                // Drop a leading join-space (block start or just after a space/newline/BR)
                if (lastWasSpace) t = t.replace(/^ +/, '');
                visibleCount += t.length;
                lastWasSpace = / $/.test(t);
            }
        }
        return visibleCount;
    }

    function hasAnyVisibleAfter(block, edgeRange, opts) {
        const {
            respectCSS = false,
            skipHidden = false,
            ignoreZeroWidth = false,
            treatNbspAsContent = true,
        } = opts || {};

        const slice = sliceRange(block, edgeRange, 'after');
        const walker = makeWalker(block, slice, {respectCSS, skipHidden});

        const NBSP = '\u00A0';

        let n;
        while ((n = walker.nextNode())) {
            if (n.nodeType === Node.ELEMENT_NODE) {
                // <br> or atomic inline → definitely visible content after
                return true;
            }
            // TEXT node
            let t = textPartForNodeInSlice(n, slice, edgeRange, 'after');
            if (!t) continue;

            if (t.indexOf('\u0000') !== -1) t = t.replace(/\u0000/g, '');
            if (ignoreZeroWidth) t = t.replace(/[\u200B\u200C\u200D\uFEFF]/g, '');

            const parentEl = /** @type {Text} */(n).parentElement;
            const preLike = isPreLike(parentEl, respectCSS);

            if (preLike) {
                // Any char after caret inside pre-like is visible
                if (t.length) return true;
            } else {
                // In normal flow, ignore ASCII whitespace; consider NBSP only if treated as content
                if (!treatNbspAsContent) t = t.replaceAll(NBSP, ' ');
                // If we have any non-ASCII-whitespace char, it's visible
                if (/[^\t\n\r\f ]/.test(t)) return true;
                // Otherwise it's only collapsible whitespace → not enough to disqualify end-of-block
            }
        }
        return false;
    }

    function resolveBlockAndBoundary(input, which, opts) {
        const r = collapsedBoundaryRange(input, which);
        if (!r) return {block: null, edgeRange: null};
        const block = nearestBlockAncestor(r.startContainer, {respectCSS: opts?.respectCSS !== false});
        return {block, edgeRange: r};
    }

    // --- Public methods ---

    /**
     * Is the selection/range boundary at the start of its block?
     * (counts with HTML whitespace collapsing)
     */
    function isAtBlockStart(input, opts = undefined) {
        const {block, edgeRange} = resolveBlockAndBoundary(input, 'start', opts);
        if (!block) return false;
        const count = countVisibleInSlice(block, edgeRange, 'before', opts);
        return count === 0;
    }

    /**
     * Is the selection/range boundary at the end of its block?
     * (ignores trailing collapsible ASCII whitespace in normal flow,
     * but treats anything in pre-like contexts as visible)
     */
    function isAtBlockEnd(input, opts = undefined) {
        const {block, edgeRange} = resolveBlockAndBoundary(input, 'end', opts);
        if (!block) return false;
        return !hasAnyVisibleAfter(block, edgeRange, opts);
    }

    /**
     * Return the collapsed visible character offset from the start of the block
     * to the specified boundary (default: start boundary).
     *
     * @returns {number}
     */
    function getVisibleOffsetFromBlockStart(input, opts = undefined) {
        const edge = (opts && opts.edge === 'end') ? 'end' : 'start';
        const {block, edgeRange} = resolveBlockAndBoundary(input, edge, opts);
        if (!block) return 0;
        return countVisibleInSlice(block, edgeRange, 'before', opts);
    }

    return {isAtBlockStart, isAtBlockEnd, getVisibleOffsetFromBlockStart};
})();

</script>

<style>
#div5 {
    user-select: none;
    pointer-events: none;
}

[contenteditable] {
    outline: none;
    box-shadow: none;
}
</style>

<style>
html {
    font: 400 10px/1 sans-serif;
}

body, h1, h2, h3, h4, h5, h6, p, pre {
    margin: 0;
    font-size: inherit;
    font-weight: inherit;
    font-family: inherit;
    line-height: inherit;
}

html {
    font-family: SF Mono, consolas, monospace, sans-serif;
    color: #333;

    background-image: linear-gradient(#eee 0.5px, transparent 0.5px);
    background-size: 100% 22px;
}

body {
    font-size: 1.6rem;
    line-height: 2.2rem;

    max-width: 35em;
    margin: 0 auto;
    padding: 8.8rem 10rem;

    background-image: linear-gradient(#f4f4f4 0.5px, transparent 0.5px);
    background-size: 100% 22px;
    background-position-y: 11px;
}

article {
    border: 1px solid #eee;
    border-top: none;
    border-bottom: none;

    padding: 0.6rem 0 1.6rem 0;
}

h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    margin-bottom: 2.2rem;
}

h1 {
    font-size: 4.1rem;
    line-height: 5.5rem;
    padding-top: 0.7rem;
    margin-bottom: 1.5rem;
}

h2 {
    font-size: 3.2rem;
    line-height: 4.4rem;
    padding-top: 0.5rem;
    margin-bottom: 1.7rem;
}

h3 {
    font-size: 2.5rem;
    line-height: 3.3rem;
    /*margin-top: 1.1rem;*/

    padding-top: 0.2rem;
    margin-bottom: 2.0rem;
}

h4 {
    font-size: 2.0rem;
    line-height: 3.3rem;
    padding-top: 0.4rem;
    margin-bottom: 1.8rem;
}

h5 {
    font-weight: 600;
}

h6 {
    font-weight: 500;
}

h5, h6, p {
    margin-bottom: 1.1rem;
}
</style>