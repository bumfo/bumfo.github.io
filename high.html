<!DOCTYPE HTML>
<title>High</title>

<style>
	pre code {
		display: block;
		outline: none;
		tab-size: 4;
		-moz-tab-size: 4;
		-o-tab-size:  4;
		white-space: pre-wrap;
	}
	code {
		color: #444;
		font-family: consolas, monospace;
	}
/*	i {
		color: #333;
		font-weight: bold;
	}
	b {
		color: #333;
	}
	u {
		color: #c7254e;
		text-decoration: none;
	}
	s {
		color: #998;
		text-decoration: none;
	}
	em {
		color: #0086B3;
		font-style: normal;
	}
	strong {
		color: #945277;
	}
	cite {
		color: #945277;
		font-style: normal;
	}*/
</style>

<pre>
<code></code>
</pre>

<script>
(function() {
	var c = document.querySelector("code");

	document.addEventListener("DOMContentLoaded", function() {
		c.textContent = document.querySelector("script").innerHTML;
		update();

		c.contentEditable = true;
		c.spellcheck = false;
	});

	c.addEventListener("input", function() {
		var t = getCaret(c);
		update();
		setCaret(t, c);
	});

	function getCaretLine(lines, t) {
		var start = t[0], end = t[1],
			startLine = -1, endLine = -1,
			lineStart, lineEnd;

		var pj;
		for (var i = 0, j = 0, n = lines.length; i < n; ++i) {
			pj = j;
			j += lines[i].length + 1;

			if (startLine === -1 && j > start) {
				lineStart = pj;
				startLine = i;
			}

			if (endLine === -1 && j > end) {
				lineEnd = j - 1;
				endLine = i;
			}

			if (j > start && j > end)
				break;
		}

		return [startLine, endLine, lineStart, lineEnd];
	}

	function previousLineTabs(lines, startLine) {
		return startLine > 0 ? lines[startLine - 1].match(/^\t*/)[0].length : 0;
	}

	function tabsInsert(t, minTabs) {
		var start = t[0], end = t[1];

		var value = c.textContent;
		var lines = value.split("\n");

		var caretLine = getCaretLine(lines, t),
			startLine = caretLine[0], endLine = caretLine[1],
			lineStart = caretLine[2], lineEnd = caretLine[3];

		var offset = 0;

		if (endLine > startLine) {
			offset = endLine - startLine + 1;
			var insertion = '\t' + lines.slice(startLine, endLine + 1).join('\n\t');

			c.textContent = value.substring(0, lineStart) + insertion + value.substring(lineEnd);

			t[0] = start + 1;
			t[1] = end + offset;
		} else {
			if (lineStart === start) {
				offset = previousLineTabs(lines, startLine);
			}

			offset = Math.max(minTabs === void(0) ? 1: minTabs, offset);

			console.log(offset);

			c.textContent = value.substring(0, start) + new Array(offset + 1).join('\t') + value.substring(end);

			t[0] = t[1] = start + offset;
		}
	}

	c.addEventListener("keydown", function(e) {
		var keyCode = e.keyCode || e.which;

		if (keyCode === 9) {
			e.preventDefault();

			var t = getCaret(c);
			tabsInsert(t);
			update();
			setCaret(t, c);
		} else if (keyCode === 13) {
			e.preventDefault();

			var t = getCaret(c);
			var start = t[0], end = t[1];
			var value = c.textContent;
			c.textContent = value.substring(0, start) + "\n" + value.substring(end);
			t[1] = t[0] = start + 1;
			tabsInsert(t, 0);
			update();
			setCaret(t, c);

			// document.execCommand("insertHTML", false, "\n");

			// tabsInsert();
		}
	});

	c.addEventListener('paste', function(e) {
		e.preventDefault();

		var t = getCaret(c);

		var s = e.clipboardData.getData('text/plain');

		c.textContent = s;

		t[1] = t[0] = t[0] + s.length;

		setCaret(t, c);
	});

	function light(a) {
		return a.replace(/(?:("|')(?:[^\\\1]|\\.)*?\1|\/\*(?:[^*]|\*(?!\/))*\*\/|\/\/.*$|((?:[=\(;:]|\n|^)\s*)((?:\/)(?![\/*])(?:[^\\\1]|\\[^ ])*?\/[gim]*))|(var)(?=[^a-zA-Z_$0-9]|$)|(if|else|for|in|while|do|with|return|new|break|continue|delete)(?=[^a-zA-Z_$0-9]|$)|([a-zA-Z_$][a-zA-Z_$0-9]*)(?=\s*[=:]\s*function)|(constructor|toExponential|toFixed|toLocaleString|toPrecision|toString|valueOf|toSource|toString|valueOf|charAt|charCodeAt|concat|indexOf|lastIndexOf|localeCompare|length|match|replace|search|slice|split|substr|substring|toLocaleLowerCase|toLocaleUpperCase|toLowerCase|toString|toUpperCase|valueOf|Method|anchor|big|blink|bold|fixed|fontcolor|fontsize|italics|link|small|strike|sub|sup|concat|every|filter|forEach|indexOf|join|lastIndexOf|map|pop|push|reduce|reduceRight|reverse|shift|slice|some|toSource|sort|splice|toString|unshift|Date|getDate|getDay|getFullYear|getHours|getMilliseconds|getMinutes|getMonth|getSeconds|getTime|getTimezoneOffset|getUTCDate|getUTCDay|getUTCFullYear|getUTCHours|getUTCMilliseconds|getUTCMinutes|getUTCMonth|getUTCSeconds|getYear|setDate|setFullYear|setHours|setMilliseconds|setMinutes|setMonth|setSeconds|setTime|setUTCDate|setUTCFullYear|setUTCHours|setUTCMilliseconds|setUTCMinutes|setUTCMonth|setUTCSeconds|setYear|toDateString|toGMTString|toLocaleDateString|toLocaleFormat|toLocaleString|toLocaleTimeString|toSource|toString|toTimeString|toUTCString|valueOf|parse|UTC|abs|acos|asin|atan|atan2|ceil|cos|exp|floor|log|max|min|pow|random|round|sin|sqrt|tan|toSource|exec|test|toSource|toString|appendChild|removeChild|replaceChild|cloneNode|compareDocumentPosition|contains|hasAttributes|hasChildNodes|insertBefore|isDefaultNamespace|isEqualNode|lookupNamespaceURI|lookupPrefix|normalize|hasAttribute|getAttribute|setAttribute|removeAttribute|addEventListener|removeEventListener|add|append|remove|caretPositionFromPoint|clear|close|createNodeIterator|createRange|createTreeWalker|elementFromPoint|registerElement|adoptNode|createAttribute|createCDATASection|createComment|createDocumentFragment|createElement|createElementNS|createEntityReference|createEvent|createExpression|createNSResolver|createProcessingInstruction|createTextNode|enableStyleSheetsForSet|evaluate|execCommand|exitPointerLock|getBoxObjectFor|getElementById|getElementsByTagName|getElementsByTagNameNS|getElementsByClassName|getElementsByName|getSelection|hasFocus|importNode|loadOverlay|open|queryCommandSupported|querySelector|querySelectorAll|releaseCapture|write|writeln|back|forward|go|pushState|replaceState)(?=\()|(function)(?=[^a-zA-Z_$0-9]|$)(\s*)((?:[a-zA-Z_$][a-zA-Z_$0-9]*)?)(?:\(([^\)]*)\))|(this|window|document)(?=[^a-zA-Z_$0-9]|$)|(0x[0-9a-fA-F]+|[0-9]+|true|false|null|undefined|NaN)(?=[^a-zA-Z_$0-9]|$)/gm, 
			function(a, b, c, d, e, f, g, h, i, j, k, l, m, n) { return b ? "<u>" + a + "</u>" : d ? c + "<u>" + d + "</u>" : e ? "<i>" + a + "</i>" : f ? "<b>" + a + "</b>" : g ? "<strong>" + a + "</strong>" : h ? "<strong>" + a + "</strong>" : i ? "<i>" + i + "</i>" + j + "<strong>" + k + "</strong>" + "(<em>" + l + "</em>)" : m ? "<em>" + m + "</em>" : n ? "<cite>" + n + "</cite>" : "<s>" + a + "</s>"; });
	}

	function encode(x) {
		return x.replace(/&/g, "&amp;").replace(/</g, "&lt;");
	}

	function update() {
		c.innerHTML = light(encode(c.textContent));
	}

	var Caret = function() {
		function some(a, f, u) {
			if (u === void(0)) u = false;
			for (var i = 0, n = a.length, r; i < n; ++i) if ((r = f(a[i], i, n)) !== u) return r;
			return u;
		}

		function getOffset(c, co, cc) {
			var cto = co, cp;
			if (c.nodeType !== 3) co = 0, some(c.childNodes, function(x, i) {
				if (i === cto) return true;
				co += x.textContent.length;
				return false;
			});
			return c === cc || cc && !cc.contains(c) ? co : function get(c, co, cc) {
				var cp = c.parentNode;
				if (c !== cp.firstChild) some(cp.childNodes, function(x) {
					if (x === c) return true;
					co += x.textContent.length;
					return false;
				});
				return cc && cc !== cp && cc.contains(cp) ? get(cp, co, cc) : co;
			}(c, co, cc);
		}

		function setOffset(cc, co, set, tion) {
			var to = co, c = cc;
			some(cc.childNodes, function(x, i, n) {
				var l = x.textContent.length; c = x;
				if (tion) {
					if (to < l) return true;
					if (to !== l || i !== n - 1) to -= l;
				} else {
					if (to <= l) return true;
					to -= l;
				}
				return false;
			});
			return c === cc || c.nodeType === 3 ? (set(c, to), c) : c = setOffset(c, to, set, tion);
		}

		return { get: getOffset, set: setOffset };
	}();

	function getCaret(x) {
		var s = window.getSelection(), r = s.getRangeAt(0);

		return (x.contains(r.startContainer)) ? 
			[Caret.get(r.startContainer, r.startOffset, x), Caret.get(r.endContainer, r.endOffset, x)] : false;
	}

	function setCaret(ro, y) {
		var s = window.getSelection(), r = document.createRange();

		if (ro) {
			Caret.set(y,ro[0],r.setStart.bind(r));
			Caret.set(y,ro[1],r.setEnd.bind(r));
			s.removeAllRanges();
			s.addRange(r);
		}
	}
}());
</script>